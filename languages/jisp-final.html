
<meta chardef="utf-8">

<script src="js/jquery.js"></script>
<script src="js/jqconsole.js"></script>
<script src="js/sugar.js"></script>
<script src="js/peg.js"></script>
<script src="js/plt.js"></script>

<script type="text/javascript">
  // uncomment next line to enable refresh
  // PLT.refresh = true

  // write helper functions and semantics here
  var sumArray = function(array) {
    var x = 0;
    for(var i=0; i<array.length; i++) {
      x += array[i];
    }
    return x;
  }
  
  var greet = function(text) {
    return "Hello " + text;
  }
  
  // ast : {first :{symbol :"+"},rest :[4,5]}
  var lookupFunction = function(functionName) {
    return eval('window.' + functionName);
  }
  
  window["ðŸ˜Ž"] = function(really) {
    return "ðŸ’° " + really + " ðŸ’°";
  }
  
  var _plus_ = function(a, b) {
    return a + b;
  }
  
  var _star_ = function(a, b) {
    return a * b;
  }
  
  var _dash_ = function(a, b) {
    return a - b;
  }
  
  var _less_ = function(a, b) {
    return a < b;
  }
  
  var _greater_ = function(a, b) {
    return a > b;
  }
  
  var _if_ = function(rest) {
    var test = rest[0];
    var trueBranch = rest[1];
    var falseBranch = rest[2];
    
    if(JispEval(test)) {
      return JispEval(trueBranch);
    } else {
      return JispEval(falseBranch);
    }
  }
  
  var JispSymbols = {}
  var JispTemporarySymbols = {}
  
  var def = function(ast) {
    var symbol = ast[0];
    var value  = ast[1];
    JispSymbols[symbol.symbol] = value;
    return value;
  }
  
  var fun = function(ast) {
    var name = ast[0];
    var args = ast[1];
    var body = ast[2];
    
    window[name.symbol] = function() {
      for (var i = 0; i < arguments.length; i++) {
        JispSymbols[args[i].symbol] =  arguments[i];
      }
      
      return JispEval(body);
    }
  }
  
  var normalizeName = function(functionName) {
    return functionName.replace(/\+/g, "_plus_").
                        replace(/-/g,  "_dash_").
                        replace(/\*/g, "_star_").
                        replace(/\//g, "_slash_").
                        replace(/</g,  "_less_").
                        replace(/>/g,  "_greater_").
                        replace(/if/g, "_if_");
  }
  
  var doesFunctionExist = function(functionName) {
    return typeof lookupFunction(functionName) == 'function';
  }
  
  var isSpecial = function(name) {
    return name == "_if_" ||
           name == "fun" ||
           name == "def";
  }
  
  var JispEval = function(ast) {
    if(ast.first != undefined && ast.rest != undefined) {
      if(isSpecial(ast.first.symbol)) {
        var functionToCall = lookupFunction(ast.first.symbol);
        return functionToCall(ast.rest);
        
      } else if(doesFunctionExist(ast.first.symbol)) {
        var functionToCall = lookupFunction(ast.first.symbol);
        if(functionToCall.length != 0 &&
           functionToCall.length != ast.rest.length) {
          return {error: "Wrong number of argument passed to " +
                          ast.first.symbol +
                          "! Expected " +
                          functionToCall.length +
                          ", got " + ast.rest.length }
        } else {
          var evaluatedRest = [];
          
          for (var i = 0; i < ast.rest.length; i++) {
            evaluatedRest[i] = JispEval(ast.rest[i]);
          }
          
          return functionToCall.apply(null, evaluatedRest);
        }
        
      } else {
        return {error: "Function " + ast.first.symbol + " not found!"}
        
      }
    } else if(ast.symbol != undefined) {
      if(JispSymbols[ast.symbol]) {
        return JispSymbols[ast.symbol];
      } else {
        return {error: "Symbol " + ast.symbol + " not found!"}
      }
      
    } else {
      return ast;
    }
  }
</script>

<title>Jisp</title>

<!--
syntax:
(if (< 8 9) "hello" "world")

ast:
{first: {symbol :"_if_"},
        rest:[{first :{symbol :"_less_"},
                      rest :[8,9]},
              "hello",
              "world"]}
 -->

<!--

PEG syntax quick reference

'x'   : match the literal character 'x'
x+    : match x 1 or more times
x*    : match x 0 or more times
x?    : match x 0 or 1 times
!x    : match anything but the match x
x/y   : match x or y, trying in that order
[xyz] : match one of the literal character 'x', 'y', or 'z'
v:x   : assign the result of the match x to the variable v

Full documentation: http://pegjs.majda.cz/documentation#grammar-syntax-and-semantics-parsing-expression-types

-->
<grammar>
  start           = space e:(parens / number) space { return JispEval(e) }
  
  expression      = string / number / list / parens / symbol
  
  // anything in (parens)
  parens          = '(' space s:symbol space a:argument* space ')'
                    { return {first:s, rest:a} }             // use this line to see what is being parsed
  list            = '[' space a:argument* space ']' { return a }
  symbol          = s:[^ ()\[\]div]+ { return {symbol: normalizeName(s.join(""))} }
  argument        = e:expression space { return e }
  
  string          = '"' a:[^"]* '"' { return a.join("") }
    
  number = d:digit+ { return parseInt( d.join('') ) }
  digit  = [0123456789]

  space  = ' '*
</grammar>

<code>(fun square [x] (* x x))</code>
<code>(square 12)</code>
<code>(fun square+n [x n] (+ n (square x)))</code>
<code>(square+n 12 30)</code>